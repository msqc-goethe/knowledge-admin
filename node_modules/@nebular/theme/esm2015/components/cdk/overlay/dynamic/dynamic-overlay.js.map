{"version":3,"file":"dynamic-overlay.js","sourceRoot":"","sources":["../../../../../../../../.ng_build/theme/components/cdk/overlay/dynamic/dynamic-overlay.ts"],"names":[],"mappings":"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","sourcesContent":["import { ComponentFactoryResolver, ComponentRef, Injectable, NgZone, Type } from '@angular/core';\nimport { filter, takeUntil, distinctUntilChanged } from 'rxjs/operators';\nimport { Subject, BehaviorSubject, Observable, merge } from 'rxjs';\n\nimport {\n  NbAdjustableConnectedPositionStrategy,\n  NbPosition,\n} from '../overlay-position';\n\nimport { NbRenderableContainer } from '../overlay-container';\nimport { createContainer, NbOverlayContent, NbOverlayService, patch } from '../overlay-service';\nimport { NbOverlayRef, NbOverlayContainer, NbOverlayConfig } from '../mapping';\n\nexport interface NbDynamicOverlayController {\n  show();\n  hide();\n  toggle();\n  rebuild();\n}\n\n@Injectable()\nexport class NbDynamicOverlay {\n\n  protected ref: NbOverlayRef;\n  protected container: ComponentRef<NbRenderableContainer>;\n  protected componentType: Type<NbRenderableContainer>;\n  protected context: Object = {};\n  protected content: NbOverlayContent;\n  protected positionStrategy: NbAdjustableConnectedPositionStrategy;\n  protected overlayConfig: NbOverlayConfig = {};\n  protected lastAppliedPosition: NbPosition;\n\n  protected positionStrategyChange$ = new Subject();\n  protected isShown$ = new BehaviorSubject<boolean>(false);\n  protected destroy$ = new Subject<void>();\n  protected overlayDestroy$ = new Subject<NbOverlayRef>();\n\n  get isAttached(): boolean {\n    return this.ref && this.ref.hasAttached();\n  }\n\n  get isShown(): Observable<boolean> {\n    return this.isShown$.pipe(distinctUntilChanged());\n  }\n\n  constructor(\n    protected overlay: NbOverlayService,\n    protected componentFactoryResolver: ComponentFactoryResolver,\n    protected zone: NgZone,\n    protected overlayContainer: NbOverlayContainer) {\n  }\n\n  create(componentType: Type<NbRenderableContainer>,\n         content: NbOverlayContent,\n         context: Object,\n         positionStrategy: NbAdjustableConnectedPositionStrategy,\n         overlayConfig: NbOverlayConfig = {}) {\n\n    this.setContentAndContext(content, context);\n    this.setComponent(componentType);\n    this.setPositionStrategy(positionStrategy);\n    this.setOverlayConfig(overlayConfig);\n\n    return this;\n  }\n\n  setContent(content: NbOverlayContent) {\n    this.content = content;\n\n    if (this.container) {\n      this.updateContext();\n    }\n    this.updatePosition();\n  }\n\n  setContext(context: Object) {\n    this.context = context;\n\n    if (this.container) {\n      this.updateContext();\n    }\n    this.updatePosition();\n  }\n\n  setContentAndContext(content: NbOverlayContent, context: Object) {\n    this.content = content;\n    this.context = context;\n    if (this.container) {\n      this.updateContext();\n    }\n    this.updatePosition();\n  }\n\n  setComponent(componentType: Type<NbRenderableContainer>) {\n    this.componentType = componentType;\n\n    // in case the component is shown we recreate it and show it back\n    const wasAttached = this.isAttached;\n    this.disposeOverlayRef();\n    if (wasAttached) {\n      this.show();\n    }\n  }\n\n  setPositionStrategy(positionStrategy: NbAdjustableConnectedPositionStrategy) {\n    this.positionStrategyChange$.next();\n\n    this.positionStrategy = positionStrategy;\n\n    this.positionStrategy.positionChange\n      .pipe(\n        filter(() => !!this.container),\n        takeUntil(\n          merge(\n            this.positionStrategyChange$,\n            this.destroy$,\n          ),\n        ),\n      )\n      .subscribe((position: NbPosition) => {\n        this.lastAppliedPosition = position;\n        patch(this.container, { position });\n      });\n\n    if (this.ref) {\n      this.ref.updatePositionStrategy(this.positionStrategy);\n    }\n  }\n\n  setOverlayConfig(overlayConfig: NbOverlayConfig) {\n    this.overlayConfig = overlayConfig;\n\n    const wasAttached = this.isAttached;\n    this.disposeOverlayRef();\n    if (wasAttached) {\n      this.show();\n    }\n  }\n\n  show() {\n    if (!this.ref) {\n      this.createOverlay();\n    }\n\n    this.renderContainer();\n\n    if (!this.hasOverlayInContainer()) {\n      // Dispose overlay ref as it refers to the old overlay container and create new by calling `show`\n      this.disposeOverlayRef();\n      return this.show();\n    }\n\n    this.isShown$.next(true);\n  }\n\n  hide() {\n    if (!this.ref) {\n      return;\n    }\n\n    this.ref.detach();\n    this.container = null;\n\n    this.isShown$.next(false);\n  }\n\n  toggle() {\n    if (this.isAttached) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  dispose() {\n    this.destroy$.next();\n    this.destroy$.complete();\n    this.hide();\n    this.disposeOverlayRef();\n    this.isShown$.complete();\n    this.positionStrategyChange$.complete();\n    this.overlayDestroy$.complete();\n  }\n\n  getContainer() {\n    return this.container;\n  }\n\n  protected createOverlay() {\n    this.ref = this.overlay.create({\n      positionStrategy: this.positionStrategy,\n      scrollStrategy: this.overlay.scrollStrategies.reposition(),\n      ...this.overlayConfig,\n    });\n    this.updatePositionWhenStable(this.ref);\n  }\n\n  protected renderContainer() {\n    const containerContext = this.createContainerContext();\n    if (!this.container) {\n      this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);\n    }\n    this.container.instance.renderContent();\n  }\n\n  protected updateContext() {\n    const containerContext = this.createContainerContext();\n    Object.assign(this.container.instance, containerContext);\n    this.container.instance.renderContent();\n    this.container.changeDetectorRef.detectChanges();\n  }\n\n  protected createContainerContext(): Object {\n    return {\n      content: this.content,\n      context: this.context,\n      cfr: this.componentFactoryResolver,\n      position: this.lastAppliedPosition,\n    };\n  }\n\n  /**\n   * Dimensions of the container may change after content update. So we listen to zone.stable event to\n   * reposition the container.\n   */\n  protected updatePositionWhenStable(overlay: NbOverlayRef) {\n    const overlayDestroy$ = this.overlayDestroy$.pipe(\n      filter((destroyedOverlay: NbOverlayRef) => destroyedOverlay === overlay),\n    );\n\n    this.zone.onStable\n      .pipe(takeUntil(merge(this.destroy$, overlayDestroy$)))\n      .subscribe(() => this.updatePosition());\n  }\n\n  protected updatePosition() {\n    if (this.ref) {\n      this.ref.updatePosition();\n    }\n  }\n\n  protected hasOverlayInContainer(): boolean {\n    return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);\n  }\n\n  protected disposeOverlayRef() {\n    if (this.ref) {\n      this.ref.dispose();\n      this.overlayDestroy$.next(this.ref);\n      this.ref = null;\n      this.container = null;\n    }\n  }\n}\n"]}